---
# This file handles the logic for fetching and deploying a single certificate,
# either from a PKI secrets engine or a KV store.
#
# Requires the following variable:
# __cert_info:
#   type: 'pki' or 'kv'
#   name: The name of the certificate file.
#   common_name: The common name (for PKI only).
#   source_path: The full path in Vault (e.g., 'kv/pki/ca/pem')
#   source_content: The certificate content (for KV type, to avoid re-fetching)
#   local_cert_path: The local directory for the cert file.
#   local_key_path: The local directory for the key file (for PKI only).
#   key_algo: The algorithm of the key (optional).
#   key_size: The size of the key (optional).

- name: "fetch-cert[{{ __cert_info.cert_name }}] : Display __cert_info"
  ansible.builtin.debug:
    var: __cert_info
  delegate_to: localhost
  run_once: true

- name: "fetch-cert[{{ __cert_info.cert_name }}] : Check if certificate file {{ __cert_info.cert_name }} exists"
  ansible.builtin.stat:
    path: "{{ __cert_info.local_cert_path }}/{{ __cert_info.cert_name }}"
  register: __cert_stat

- name: "fetch-cert[{{ __cert_info.cert_name }}] : Set __key_algo"
  when: __cert_info.key_algo | d('') | length > 0
  ansible.builtin.set_fact:
    __key_algo: "{{ (__cert_info.key_algo == 'ecdsa') | ternary('ec', __cert_info.key_algo) }}"

- name: "fetch-cert[{{ __cert_info.cert_name }}] : Validate existing certificate {{ __cert_info.cert_name }}"
  when: __cert_stat.stat.exists
  dettonville.utils.x509_certificate_verify:
    path: "{{ __cert_info.local_cert_path }}/{{ __cert_info.cert_name }}"
    common_name: "{{ __cert_info.common_name | d(omit) }}"
    key_algo: "{{ __key_algo | d(omit) }}"
    key_size: "{{ __cert_info.key_size | d(omit) }}"
    validate_expired: true
  register: __cert_verify_result

- name: "fetch-cert[{{ __cert_info.cert_name }}] : Retrieve and deploy pki certificate from Vault"
  when:
    - (not __cert_stat.stat.exists) or __cert_verify_result.verify_failed | d(true) | bool
  block:
    - name: "fetch-cert[{{ __cert_info.cert_name }}] : Deploy certificate from KV store"
      when: __cert_info.type == "kv"
      block:
        - name: "fetch-cert[{{ __cert_info.cert_name }}] : Retrieve pki certificate from Vault (KV store)"
          when:
            - __cert_info.source_content | d('') | length == 0
            - __cert_info.source_path | d('') | length > 0
          community.hashi_vault.vault_kv2_get:
            url: "{{ deploy_pki_certs__vault_url }}"
            token: "{{ deploy_pki_certs__vault_token }}"
            mount_point: "{{ deploy_pki_certs__vault_kv_mount_path }}"
            path: "{{ __cert_info.source_path }}"
#            path: "{{ (__cert_info.source_path.split('/'))[1:] | join('/') }}"
#            engine_mount_point: "{{ deploy_pki_certs__vault_kv_mount_path
#              | d(__cert_info.source_path.split('/')[0] | d('secret')) }}"
            validate_certs: false
          register: __kv_fetch_result
          delegate_to: localhost
          run_once: true

        - name: "fetch-cert[{{ __cert_info.cert_name }}] : Display __kv_fetch_result"
          ansible.builtin.debug:
            var: __kv_fetch_result
            verbosity: 1
          delegate_to: localhost

        - name: "fetch-cert[{{ __cert_info.cert_name }}] : Deploy new certificate (from KV store)"
          ansible.builtin.copy:
            content: "{{ __kv_fetch_result.data.data.certificate | d(__kv_fetch_result.secret.certificate) }}"
            dest: "{{ __cert_info.local_cert_path }}/{{ __cert_info.cert_name }}"
            mode: '0644'
          register: __cert_deploy_result

    - name: "fetch-cert[{{ __cert_info.cert_name }}] : Deploy intermediate CA from PKI engine CA endpoint"
      when: __cert_info.type == "intermediate_ca"
      block:
        - name: "fetch-cert[{{ __cert_info.cert_name }}] : Retrieve pki certificate from Vault (PKI engine)"
          ansible.builtin.uri:  # Fixed: Use uri for PEM
            url: "{{ deploy_pki_certs__vault_url }}/{{
              deploy_pki_certs__vault_api_version }}/{{ deploy_pki_certs__vault_mount_path }}/ca/pem"
            headers:
              X-Vault-Token: "{{ deploy_pki_certs__vault_token }}"
              Accept: "application/pem-certificate"
            method: GET
            return_content: true
            validate_certs: false
            status_code: 200
            body_format: raw
          register: __pki_ca_result
          delegate_to: localhost

        - name: "fetch-cert[{{ __cert_info.cert_name }}] : Deploy new intermediate CA certificate (from PKI engine)"
          ansible.builtin.copy:
            content: "{{ __pki_ca_result.content }}"
            dest: "{{ __cert_info.local_cert_path }}/{{ __cert_info.cert_name }}"
            mode: '0644'
          register: __cert_deploy_result

    - name: "fetch-cert[{{ __cert_info.cert_name }}] : Deploy certificate from PKI engine"
      when: __cert_info.type == "pki"
      block:
        - name: "fetch-cert[{{ __cert_info.cert_name }}] : Debug PKI configuration"
          ansible.builtin.debug:
            msg:
              - "PKI Mount Point: {{ deploy_pki_certs__vault_mount_path }}"
              - "Role Name: {{ deploy_pki_certs__vault_pki_cert_role_name }}"
              - "Common Name: {{ __cert_info.common_name }}"
              - "Vault URL: {{ deploy_pki_certs__vault_url }}"
              - "Certificate Issuance URL: {{ deploy_pki_certs__vault_url }}/{{ deploy_pki_certs__vault_api_version }}/{{
                deploy_pki_certs__vault_mount_path }}/issue/{{ deploy_pki_certs__vault_pki_cert_role_name }}"

        - name: "fetch-cert[{{ __cert_info.cert_name }}] : Validate PKI mount and issuer"
          community.hashi_vault.vault_read:
            url: "{{ deploy_pki_certs__vault_url }}"
            token: "{{ deploy_pki_certs__vault_token }}"
            path: "{{ deploy_pki_certs__vault_mount_path }}/config/urls"
            validate_certs: false
          register: __pki_config_result
          delegate_to: localhost
          run_once: true
          failed_when: >
            __pki_config_result.failed or
            __pki_config_result.data is not defined

        - name: "fetch-cert[{{ __cert_info.cert_name }}] : Validate internal-api role exists"
          community.hashi_vault.vault_read:
            url: "{{ deploy_pki_certs__vault_url }}"
            token: "{{ deploy_pki_certs__vault_token }}"
            path: "{{ deploy_pki_certs__vault_mount_path }}/roles/{{ deploy_pki_certs__vault_pki_cert_role_name }}"
            validate_certs: false
          register: __pki_role_result
          delegate_to: localhost
          run_once: true
          failed_when: __pki_role_result.failed or __pki_role_result.data is not defined

#        - name: "fetch-cert[{{ __cert_info.cert_name }}] : Stat host's private key file"
#          ansible.builtin.stat:
#            path: "{{ __cert_info.local_key_path }}/{{ __cert_info.cert_name | regex_replace('\\.crt$', '.key') }}"
#          register: __host_key_stat
#
#        - name: "fetch-cert[{{ __cert_info.cert_name }}] : Create host's private key if it doesn't exist"
#          when: not __host_key_stat.stat.exists
#          community.crypto.openssl_privatekey:
#            path: "{{ __cert_info.local_key_path }}/{{ __cert_info.cert_name | regex_replace('\\.crt$', '.key') }}"
#            type: "{{ __cert_info.key_algo | d('RSA') }}"
#            size: "{{ __cert_info.key_size | d(4096) }}"
#          register: __host_key_result
#          delegate_to: "{{ inventory_hostname }}"
#
#        - name: "fetch-cert[{{ __cert_info.cert_name }}] : Create CSR for the certificate"
#          community.crypto.openssl_csr:
#            path: "{{ __cert_info.local_cert_path }}/{{ __cert_info.cert_name | regex_replace('\\.crt$', '.csr') }}"
#            privatekey_path: "{{ __cert_info.local_key_path }}/{{ __cert_info.cert_name | regex_replace('\\.crt$', '.key') }}"
#            common_name: "{{ __cert_info.common_name }}"
#            extended_key_usage:
#              - "serverAuth"
#              - "clientAuth"
#          register: __pki_csr_result
#          delegate_to: "{{ inventory_hostname }}"

        - name: "fetch-cert[{{ __cert_info.cert_name }}] : Request certificate from Vault (PKI engine)"
          community.hashi_vault.vault_pki_generate_certificate:
            url: "{{ deploy_pki_certs__vault_url }}"
            token: "{{ deploy_pki_certs__vault_token }}"
            engine_mount_point: "{{ deploy_pki_certs__vault_mount_path }}"
            role_name: "{{ deploy_pki_certs__vault_pki_cert_role_name }}"
            common_name: "{{ __cert_info.common_name }}"
            ttl: "{{ deploy_pki_certs__certificate_ttl }}"
            validate_certs: false
          register: __pki_fetch_result
          delegate_to: localhost

        - name: "fetch-cert[{{ __cert_info.cert_name }}] : Display __pki_fetch_result"
          ansible.builtin.debug:
            var: __pki_fetch_result
            verbosity: 1

        - name: "fetch-cert[{{ __cert_info.cert_name }}] : Deploy new certificate (from PKI engine)"
          ansible.builtin.copy:
            content: "{{ __pki_fetch_result.data.data.certificate | d(__pki_fetch_result.data.certificate) }}"
            dest: "{{ __cert_info.local_cert_path }}/{{ __cert_info.cert_name }}"
            owner: root
            group: root
            mode: '0644'
          register: __cert_deploy_result

        - name: "fetch-cert[{{ __cert_info.cert_name }}] : Deploy new private key"
          ansible.builtin.copy:
            content: "{{ __pki_fetch_result.data.data.private_key | d(__pki_fetch_result.data.private_key) }}"
            dest: "{{ __cert_info.local_key_path }}/{{ __cert_info.cert_name | regex_replace('\\.crt$', '.key') }}"
            owner: root
            group: root
            mode: '0600'

- name: "fetch-cert[{{ __cert_info.cert_name }}] : Set __ca_cert_has_changed"
  when: __cert_deploy_result.changed | d(false) # noqa: no-handler
  ansible.builtin.set_fact:
    __ca_cert_has_changed: true
