
Handling the ansible inventory can have some frustrating characteristics – one of which is the difficulty in capturing lists of hosts which have failed and carrying out remedial operations.

##### First Attempt

For quite a while I’ve resorted to doing what I assume most people do, which is to capture the output log and grep for failures, successes, write them into individual files and deal with them later.   After that I tried experimenting with using ‘block’ and ‘rescue’, however this doesn’t prevent the host from being removed from subsequent plays;  resetting the meta vars can get around this but its messy and hard to follow whats going on when reading the code.

##### Second Attempt

So, my second attempt at resolving this (first proper attempt) involved carrying out checks on the hosts (such as running the ‘ping’ or ‘setup’ modules) and setting a fact afterwards.   If the check passed, then the fact would get set and that would indicate the task worked.   Here’s an example –

<table><tbody><tr><td><p>1</p><p>2</p><p>3</p><p>4</p><p>5</p><p>6</p><p>7</p><p>8</p><p>9</p></td><td><div><p><code>- name: Check ssh connection works with a basic command</code></p><p><code>&nbsp;&nbsp;&nbsp;</code><code>raw: whoami</code></p><p><code>&nbsp;&nbsp;&nbsp;</code><code>register: connect_test</code></p><p><code>&nbsp;&nbsp;&nbsp;</code><code>changed_when: false</code></p><p><code>&nbsp;</code><code>- name: Set passed host connection fact</code></p><p><code>&nbsp;&nbsp;&nbsp;</code><code>set_fact:</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code>passed_connection: true</code></p><p><code>&nbsp;&nbsp;&nbsp;</code><code>when: connect_test.rc == 0</code></p></div></td></tr></tbody></table>

Here, I check you can ssh onto the server using ‘raw’ (in case it’s a server without Python installed).    The next step sets a fact called ‘passed\_connection’ as true.    There’s a when condition here checking if the return code of the raw command was zero, but it’s not actually needed – if the raw command fails the playbook won’t move onto this step for the failed host, it’ll just move onto the next host in the list.

This approach also worked when delegating to another host – so doing an nslookup of the inventory host from the host the playbook is running from – 

<table><tbody><tr><td><p>1</p><p>2</p><p>3</p><p>4</p><p>5</p><p>6</p><p>7</p><p>8</p><p>9</p><p>10</p></td><td><div><p><code>- name: Check DNS name resolves for inventory hostname</code></p><p><code>&nbsp;&nbsp;</code><code>shell: "nslookup {{ inventory_hostname }}"</code></p><p><code>&nbsp;&nbsp;</code><code>ignore_errors: true</code></p><p><code>&nbsp;&nbsp;</code><code>register: dns_lookup</code></p><p><code>&nbsp;&nbsp;</code><code>delegate_to: localhost</code></p><p><code>- name: Set dns_resolves fact</code></p><p><code>&nbsp;&nbsp;</code><code>set_fact:</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><code>dns_resolves: true</code></p><p><code>&nbsp;&nbsp;</code><code>when: dns_lookup.rc == 0</code></p></div></td></tr></tbody></table>

This example is slightly different to the first in that ‘ignore\_errors’ is set to true – this means that even if it fails it will still move onto the next task, which sets the dns\_resolves fact to true; however if it has failed, this fact won’t be set because the when condition \*is\* used this time around.

  
Once the facts are set for our successful hosts, we then need to make use of them.   My idea was to have a play that ran at the end of all my other tasks that read the facts and used them to create lists of the status of each host.    I accomplished this using a combination of jinja2 and set\_fact like this –

<table><tbody><tr><td><p>1</p><p>2</p><p>3</p><p>4</p><p>5</p><p>6</p><p>7</p><p>8</p><p>9</p><p>10</p><p>11</p><p>12</p><p>13</p><p>14</p><p>15</p><p>16</p><p>17</p><p>18</p><p>19</p><p>20</p></td><td><div><p><code>- set_fact:</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><code>unreachable_hosts: "{% set unreachable_hosts = [] %}{% for host in ansible_play_hosts_all %}{% if hostvars[host]['passed_connection'] is undefined %}{{ unreachable_hosts.append(host) }}{% endif %}{% endfor %}{{ unreachable_hosts }}"</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><code>no_facts_hosts: "{% set no_facts_hosts = [] %}{% for host in ansible_play_hosts_all %}{% if hostvars[host]['passed_fact_gathering'] is undefined %}{{ no_facts_hosts.append(host) }}{% endif %}{% endfor %}{{ no_facts_hosts }}"</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><code>no_ssh_hosts: "{% set ssh_port_not_avail_hosts = [] %}{% for host in ansible_play_hosts_all %}{% if hostvars[host]['ssh_port_available'] is undefined %}{{ ssh_port_not_avail_hosts.append(host) }}{% endif %}{% endfor %}{{ ssh_port_not_avail_hosts }}"</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><code>no_dns_hosts: "{% set no_dns_hosts = [] %}{% for host in ansible_play_hosts_all %}{% if hostvars[host]['dns_resolves'] is undefined %}{{ no_dns_hosts.append(host) }}{% endif %}{% endfor %}{{ no_dns_hosts }}"</code></p><p><code>&nbsp;&nbsp;&nbsp;</code><code>delegate_facts: true</code></p><p><code>&nbsp;&nbsp;&nbsp;</code><code>delegate_to: localhost</code></p><p><code>&nbsp;&nbsp;&nbsp;</code><code>run_once: true</code></p><p><code>- set_fact:</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code>unsuccessful_hosts: "{{ ansible_play_hosts_all|difference(ansible_play_hosts)}}"</code></p><p><code>&nbsp;&nbsp;&nbsp;</code><code>delegate_facts: true</code></p><p><code>&nbsp;&nbsp;&nbsp;</code><code>delegate_to: localhost</code></p><p><code>&nbsp;&nbsp;&nbsp;</code><code>run_once: true</code></p><p><code>- set_fact:</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code>failed_hosts: "{{ hostvars['localhost']['unsuccessful_hosts']|difference(hostvars['localhost']['unreachable_hosts'])}}"</code></p><p><code>&nbsp;&nbsp;&nbsp;</code><code>delegate_facts: true</code></p><p><code>&nbsp;&nbsp;&nbsp;</code><code>delegate_to: localhost</code></p><p><code>&nbsp;&nbsp;&nbsp;</code><code>run_once: true</code></p></div></td></tr></tbody></table>

Not particularly elegant at all – the first set\_fact involves looping through all the hosts in the inventory, looking at whether they have certain facts set and if so using jinja2 to add them to lists, which are in turn set as a fact on localhost using a combination of delegate\_to, delegate\_facts and run\_once.   

The second set\_fact attempts to determine what hosts failed by looking at the difference between which hosts are left in the play\_hosts group and how many were originally in the play (ansible\_play\_hosts\_all) – this list includes all hosts that failed to connect and those that failed to complete some operation during the playbook run.

The final set\_fact operation works out which hosts were reachable, but still failed.  This information was then written to a report for later analysis.   

All this is ok, but its a lot of complex, hard to follow code that doesn’t really accomplish what I wanted to.

##### Third Attempt

So this brings me to today, my third attempt to resolve this, and it’s much cleaner.  I discovered the ‘add\_host’ module and it’s opened up a whole new world of possibilities. It lets you add a host to an inventory group in memory (including one that doesn’t yet exist, creating it), to allow you to use it in a later play. The only downside is that you can’t use it in the conventional sense – I expected to do something like this –

<table><tbody><tr><td><p>1</p><p>2</p><p>3</p><p>4</p><p>5</p><p>6</p><p>7</p><p>8</p><p>9</p></td><td><div><p><code>name: check ssh</code></p><p><code>ping:</code></p><p><code>register: ping_check</code></p><p><code>ignore_errors: true</code></p><p><code>add_host:</code></p><p><code>&nbsp;&nbsp;</code><code>host: "{{ inventory_hostname }}"</code></p><p><code>&nbsp;&nbsp;</code><code>groups: "failed_ping"</code></p><p><code>when: ping_check.failed == True</code></p></div></td></tr></tbody></table>

but no… turns out ‘add\_host’ will only ever run once per play, like having ‘run\_once: true’ hardcoded into it. It took me ages to work out why I was only ever getting one host added to my group, when I had an inventory of around 200 all calling that task in turn.

It’s not a dealbreaker though as you can use ‘with\_items’ to pass in more hosts. I found using a separate play works well like this –

<table><tbody><tr><td><p>1</p><p>2</p><p>3</p><p>4</p><p>5</p><p>6</p><p>7</p><p>8</p></td><td><div><p><code>- hosts: localhost</code></p><p><code>&nbsp;&nbsp;</code><code>gather_facts: no</code></p><p><code>&nbsp;&nbsp;</code><code>become: false</code></p><p><code>&nbsp;&nbsp;</code><code>tasks:</code></p><p><code>&nbsp;&nbsp;&nbsp;</code><code>- add_host:</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code>hostname: "{{ item }}"</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code>groups: "resolve_check_{{ hostvars[item]['resolve_check_status'] }}"</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code>with_items: "{{ groups['all'] }}"</code></p></div></td></tr></tbody></table>

So here, I’ve got a play running only against localhost, with one ‘add\_host’ task, which loops through the entire ‘groups\[‘all’\]’ list – all the hosts in our inventory. In an earlier play I’ve set a fact called resolve\_check\_status (setting it to passed or failed depending on the results of the task before it), and use that to determine what group each host goes into. At the end of this play, I’ll have two groups, one called ‘resolve\_check\_passed’ containing all the hosts that passed my dns check, and one called ‘resolve\_check\_failed’ containing all the ones that didn’t.

Here’s the playbook in full –

<table><tbody><tr><td><p>1</p><p>2</p><p>3</p><p>4</p><p>5</p><p>6</p><p>7</p><p>8</p><p>9</p><p>10</p><p>11</p><p>12</p><p>13</p><p>14</p><p>15</p><p>16</p><p>17</p><p>18</p><p>19</p><p>20</p><p>21</p><p>22</p><p>23</p><p>24</p><p>25</p><p>26</p><p>27</p><p>28</p><p>29</p><p>30</p><p>31</p><p>32</p><p>33</p><p>34</p><p>35</p><p>36</p><p>37</p><p>38</p><p>39</p><p>40</p><p>41</p><p>42</p><p>43</p><p>44</p><p>45</p><p>46</p><p>47</p><p>48</p><p>49</p><p>50</p><p>51</p></td><td><div><p><code>---</code></p><p><code># Creates groups resolve_check_passed and resolve_check_failed</code></p><p><code>- hosts: all</code></p><p><code>&nbsp;&nbsp;</code><code>gather_facts: no</code></p><p><code>&nbsp;&nbsp;</code><code>become: false</code></p><p><code>&nbsp;&nbsp;</code><code>tasks:</code></p><p><code>&nbsp;&nbsp;&nbsp;</code><code>- set_fact:</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code>connection: "{% if inventory_hostname == \"localhost\" -%}local{% else -%}ssh{%- endif %}"</code></p><p><code>&nbsp;&nbsp;&nbsp;</code><code>- name: Check hostname resolves</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code>shell: "nslookup {{ inventory_hostname }}"</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code>delegate_to: localhost</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code>connection: "{{ connection }}"</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code>become: false</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code>ignore_errors: true</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code>register: resolve_check</code></p><p><code>&nbsp;&nbsp;&nbsp;</code><code>- name: set_success_fact</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code>set_fact:</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code>resolve_check_status: passed</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code>when: resolve_check.failed != true</code></p><p><code>&nbsp;&nbsp;&nbsp;</code><code>- name: set_failure_fact</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code>set_fact:</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code>resolve_check_status: failed</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code>when: resolve_check.failed == true</code></p><p><code>- hosts: localhost</code></p><p><code>&nbsp;&nbsp;</code><code>gather_facts: no</code></p><p><code>&nbsp;&nbsp;</code><code>become: false</code></p><p><code>&nbsp;&nbsp;</code><code>tasks:</code></p><p><code>&nbsp;&nbsp;&nbsp;</code><code>- add_host:</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code>hostname: "{{ item }}"</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code>groups: "resolve_check_{{ hostvars[item]['resolve_check_status'] }}"</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code>with_items: "{{ groups['all'] }}"</code></p><p><code>- hosts: localhost</code></p><p><code>&nbsp;&nbsp;</code><code>gather_facts: no</code></p><p><code>&nbsp;&nbsp;</code><code>become: false</code></p><p><code>&nbsp;&nbsp;</code><code>connection: local</code></p><p><code>&nbsp;&nbsp;</code><code>tasks:</code></p><p><code>&nbsp;&nbsp;&nbsp;</code><code>- name: total hosts</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code>debug:</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code>msg: "{{ groups['all'] }}"</code></p><p><code>&nbsp;&nbsp;&nbsp;</code><code>- name: number of hosts passed dns</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code>debug:</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code>msg: "{{ groups['resolve_check_passed'] }}"</code></p><p><code>&nbsp;&nbsp;&nbsp;</code><code>- name: number of hosts failed dns</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code>debug:</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code>msg: "{{ groups['resolve_check_failed'] }}"</code></p></div></td></tr></tbody></table>

At the bottom is just a quick debug to print out the contents of each list. My plan here would be to create these groups for each task I need to check and use them to determine what subsequent plays to run on the hosts.